export const examsData = [
  {
    title: 'Algorithmique et structures de données',
    desc: 'Évaluation des connaissances en algorithmique, complexité et structures de données',
    time: 90,
    questions: [
      {
        title: 'Quelle est la complexité temporelle de la recherche binaire ?',
        commentary: 'Question sur la complexité algorithmique',
        isQcm: true,
        isMultiple: false,
        maxPoints: 4,
        answers: [
          { answer: 'O(n)', isCorrect: false },
          { answer: 'O(log n)', isCorrect: true },
          { answer: 'O(n²)', isCorrect: false },
          { answer: 'O(1)', isCorrect: false },
        ],
      },
      {
        title: 'Quelles structures de données utilisent le principe LIFO ?',
        commentary: 'Question sur les structures de données',
        isQcm: true,
        isMultiple: true,
        maxPoints: 4,
        answers: [
          { answer: 'Pile (Stack)', isCorrect: true },
          { answer: 'File (Queue)', isCorrect: false },
          { answer: 'Tableau', isCorrect: false },
          { answer: 'Liste chaînée inversée', isCorrect: false },
        ],
      },
      {
        title: 'Quel algorithme de tri a une complexité moyenne de O(n log n) ?',
        commentary: 'Question sur les algorithmes de tri',
        isQcm: true,
        isMultiple: false,
        maxPoints: 4,
        answers: [
          { answer: 'Tri à bulles', isCorrect: false },
          { answer: 'Tri fusion (Merge Sort)', isCorrect: true },
          { answer: 'Tri par sélection', isCorrect: false },
          { answer: 'Tri par insertion', isCorrect: false },
        ],
      },
      {
        title:
          'Expliquez la différence entre un algorithme de parcours en profondeur (DFS) et en largeur (BFS) sur un graphe.',
        commentary: 'Question ouverte sur les algorithmes de parcours',
        isQcm: false,
        isMultiple: false,
        maxPoints: 8,
        possibleCustomAnswers: [
          'Le DFS explore en profondeur en utilisant une pile (récursion ou itératif), tandis que le BFS explore en largeur niveau par niveau en utilisant une file. DFS est utilisé pour détecter les cycles, BFS pour trouver le plus court chemin.',
          "DFS parcourt le graphe en allant le plus loin possible avant de revenir en arrière. BFS visite tous les voisins d'un nœud avant de passer au niveau suivant. DFS utilise moins de mémoire mais BFS garantit le chemin le plus court.",
          "Le parcours en profondeur va jusqu'au bout d'une branche avant d'explorer les autres, utilisant une approche récursive. Le parcours en largeur explore tous les nœuds à distance k avant ceux à distance k+1.",
        ],
      },
    ],
  },
  {
    title: 'Bases de données relationnelles et SQL',
    desc: 'Examen sur les concepts de bases de données, modélisation et requêtes SQL',
    time: 120,
    questions: [
      {
        title: "Qu'est-ce qu'une clé primaire dans une base de données ?",
        commentary: 'Question sur les concepts de base',
        isQcm: true,
        isMultiple: false,
        maxPoints: 3,
        answers: [
          { answer: 'Un identifiant unique pour chaque enregistrement', isCorrect: true },
          { answer: 'Une clé qui peut contenir des valeurs NULL', isCorrect: false },
          { answer: 'Une clé qui peut avoir des doublons', isCorrect: false },
          { answer: 'Un index sur plusieurs colonnes', isCorrect: false },
        ],
      },
      {
        title: 'Quelles sont les propriétés ACID en base de données ? (Plusieurs réponses)',
        commentary: 'Question sur les transactions',
        isQcm: true,
        isMultiple: true,
        maxPoints: 4,
        answers: [
          { answer: 'Atomicité', isCorrect: true },
          { answer: 'Cohérence', isCorrect: true },
          { answer: 'Isolation', isCorrect: true },
          { answer: 'Durabilité', isCorrect: true },
        ],
      },
      {
        title: 'Quelle clause SQL permet de filtrer les résultats après un GROUP BY ?',
        commentary: 'Question sur les requêtes SQL',
        isQcm: true,
        isMultiple: false,
        maxPoints: 3,
        answers: [
          { answer: 'WHERE', isCorrect: false },
          { answer: 'HAVING', isCorrect: true },
          { answer: 'FILTER', isCorrect: false },
          { answer: 'SELECT', isCorrect: false },
        ],
      },
      {
        title:
          'Expliquez la différence entre une jointure INNER JOIN et LEFT JOIN avec des exemples.',
        commentary: 'Question ouverte sur les jointures SQL',
        isQcm: false,
        isMultiple: false,
        maxPoints: 5,
        possibleCustomAnswers: [
          "INNER JOIN retourne uniquement les lignes qui ont une correspondance dans les deux tables. LEFT JOIN retourne toutes les lignes de la table de gauche, même si elles n'ont pas de correspondance dans la table de droite (valeurs NULL).",
          'Avec INNER JOIN on obtient seulement les enregistrements qui existent dans les deux tables. LEFT JOIN garde tous les enregistrements de la première table et ajoute NULL pour ceux sans correspondance dans la deuxième.',
          'INNER JOIN est une intersection entre deux tables, LEFT JOIN garde la table de gauche complète et ajoute les correspondances de droite quand elles existent.',
        ],
      },
      {
        title: 'Décrivez les trois formes normales (1NF, 2NF, 3NF) et leur importance.',
        commentary: 'Question ouverte sur la normalisation',
        isQcm: false,
        isMultiple: false,
        maxPoints: 5,
        possibleCustomAnswers: [
          '1NF : chaque colonne contient des valeurs atomiques. 2NF : 1NF + pas de dépendance partielle (tous les attributs dépendent de la clé complète). 3NF : 2NF + pas de dépendance transitive. Ces formes éliminent les redondances et anomalies.',
          'La 1NF élimine les valeurs multiples dans les colonnes. La 2NF assure que chaque attribut non-clé dépend de toute la clé primaire. La 3NF élimine les dépendances entre attributs non-clés. Cela réduit la duplication de données.',
          'Première forme normale : valeurs atomiques et pas de groupes répétitifs. Deuxième : dépendance fonctionnelle complète à la clé. Troisième : pas de dépendance transitive entre attributs non-clés.',
        ],
      },
    ],
  },
  {
    title: 'Développement Web Frontend - HTML/CSS/JavaScript',
    desc: 'Évaluation des compétences en développement web côté client',
    time: 90,
    questions: [
      {
        title: 'Quel est le rôle du CSS ?',
        commentary: 'Question de base sur le CSS',
        isQcm: true,
        isMultiple: false,
        maxPoints: 3,
        answers: [
          { answer: 'Gérer la base de données', isCorrect: false },
          { answer: 'Styliser les pages web', isCorrect: true },
          { answer: 'Créer des animations 3D', isCorrect: false },
          { answer: 'Compiler le code', isCorrect: false },
        ],
      },
      {
        title:
          'Quelles méthodes JavaScript sont utilisées pour manipuler le DOM ? (Plusieurs réponses)',
        commentary: 'Question sur la manipulation du DOM',
        isQcm: true,
        isMultiple: true,
        maxPoints: 4,
        answers: [
          { answer: 'querySelector()', isCorrect: true },
          { answer: 'getElementById()', isCorrect: true },
          { answer: 'appendChild()', isCorrect: true },
          { answer: 'connect()', isCorrect: false },
        ],
      },
      {
        title: 'Quelle propriété CSS permet de créer une mise en page flexible ?',
        commentary: 'Question sur le CSS moderne',
        isQcm: true,
        isMultiple: false,
        maxPoints: 3,
        answers: [
          { answer: 'display: block', isCorrect: false },
          { answer: 'display: flex', isCorrect: true },
          { answer: 'display: inline', isCorrect: false },
          { answer: 'display: table', isCorrect: false },
        ],
      },
      {
        title: 'Expliquez la différence entre let, const et var en JavaScript.',
        commentary: 'Question ouverte sur les variables JavaScript',
        isQcm: false,
        isMultiple: false,
        maxPoints: 5,
        possibleCustomAnswers: [
          'var a une portée de fonction et peut être redéclarée. let a une portée de bloc et ne peut pas être redéclarée. const a une portée de bloc et ne peut être ni redéclarée ni réassignée. let et const sont préférés en JavaScript moderne.',
          "var est l'ancienne façon de déclarer des variables avec hoisting. let permet de déclarer des variables mutables avec portée de bloc. const crée des constantes dont la référence ne peut pas changer. let et const évitent les bugs liés à var.",
          "var : portée fonction, hoisting. let : portée bloc, mutable. const : portée bloc, immutable (la référence). Avec const, on peut modifier les propriétés d'un objet mais pas réassigner la variable.",
        ],
      },
      {
        title: "Qu'est-ce que le Virtual DOM et pourquoi est-il utilisé dans React ?",
        commentary: 'Question ouverte sur React',
        isQcm: false,
        isMultiple: false,
        maxPoints: 5,
        possibleCustomAnswers: [
          'Le Virtual DOM est une représentation en mémoire du DOM réel. React compare le Virtual DOM avec le DOM réel et met à jour seulement ce qui a changé (reconciliation). Cela optimise les performances en évitant les manipulations directes du DOM.',
          "C'est une copie légère du DOM gardée en mémoire. React utilise un algorithme de diff pour identifier les changements et n'applique que les modifications nécessaires au vrai DOM. Cela rend les mises à jour plus rapides.",
          "Le Virtual DOM permet à React de calculer les changements nécessaires avant de toucher au DOM réel. Il compare l'ancien et le nouveau Virtual DOM, puis applique le minimum de modifications. Cela améliore considérablement les performances.",
        ],
      },
    ],
  },
  {
    title: 'Développement Backend - API REST et Node.js',
    desc: 'Examen sur les concepts backend, API REST et Node.js',
    time: 120,
    questions: [
      {
        title: 'Quelle méthode HTTP est utilisée pour créer une ressource ?',
        commentary: 'Question sur les méthodes HTTP',
        isQcm: true,
        isMultiple: false,
        maxPoints: 3,
        answers: [
          { answer: 'GET', isCorrect: false },
          { answer: 'POST', isCorrect: true },
          { answer: 'DELETE', isCorrect: false },
          { answer: 'UPDATE', isCorrect: false },
        ],
      },
      {
        title:
          'Quels sont les codes de statut HTTP pour une requête réussie ? (Plusieurs réponses)',
        commentary: 'Question sur les codes HTTP',
        isQcm: true,
        isMultiple: true,
        maxPoints: 4,
        answers: [
          { answer: '200 OK', isCorrect: true },
          { answer: '201 Created', isCorrect: true },
          { answer: '404 Not Found', isCorrect: false },
          { answer: '500 Internal Server Error', isCorrect: false },
        ],
      },
      {
        title: 'Quel middleware Express permet de parser le corps des requêtes JSON ?',
        commentary: 'Question sur Express.js',
        isQcm: true,
        isMultiple: false,
        maxPoints: 3,
        answers: [
          { answer: 'express.static()', isCorrect: false },
          { answer: 'express.json()', isCorrect: true },
          { answer: 'express.Router()', isCorrect: false },
          { answer: 'express.urlencoded()', isCorrect: false },
        ],
      },
      {
        title: "Expliquez les principes REST et les contraintes d'une API RESTful.",
        commentary: 'Question ouverte sur REST',
        isQcm: false,
        isMultiple: false,
        maxPoints: 5,
        possibleCustomAnswers: [
          'REST utilise les méthodes HTTP (GET, POST, PUT, DELETE), des URI pour identifier les ressources, est stateless (pas de session côté serveur), utilise des formats standards (JSON/XML), et permet la mise en cache. Les ressources sont manipulées via leurs représentations.',
          'Une API REST doit être : stateless (chaque requête contient toutes les infos nécessaires), client-serveur (séparation des préoccupations), cacheable, avoir une interface uniforme (URI, méthodes HTTP), et être layered (architecture en couches).',
          "Les principes REST incluent l'utilisation des verbes HTTP de manière sémantique, des URL descriptives pour les ressources, pas d'état de session sur le serveur, des réponses cacheables, et une architecture découplée client-serveur.",
        ],
      },
      {
        title: "Qu'est-ce que le middleware dans Express.js et donnez des exemples d'utilisation.",
        commentary: 'Question ouverte sur les middlewares',
        isQcm: false,
        isMultiple: false,
        maxPoints: 5,
        possibleCustomAnswers: [
          "Un middleware est une fonction qui a accès aux objets request et response et peut modifier la requête ou la réponse. Exemples : authentication, logging, parsing JSON, gestion d'erreurs, CORS. Ils s'exécutent dans l'ordre de déclaration.",
          "Les middlewares interceptent les requêtes HTTP avant qu'elles n'atteignent les routes. On les utilise pour l'authentification (vérifier les tokens), le logging (enregistrer les requêtes), parser les données (body-parser), gérer les erreurs, ou ajouter des headers CORS.",
          "C'est une fonction qui traite la requête entre sa réception et la réponse. Exemples : express.json() pour parser JSON, morgan pour les logs, helmet pour la sécurité, des middlewares custom pour vérifier l'authentification ou valider les données.",
        ],
      },
    ],
  },
  {
    title: 'Sécurité informatique et cryptographie',
    desc: 'Évaluation sur les concepts de sécurité, authentification et cryptographie',
    time: 90,
    questions: [
      {
        title: "Qu'est-ce que le hashing ?",
        commentary: 'Question sur la cryptographie',
        isQcm: true,
        isMultiple: false,
        maxPoints: 4,
        answers: [
          { answer: 'Un algorithme de chiffrement réversible', isCorrect: false },
          { answer: 'Une fonction à sens unique qui génère une empreinte', isCorrect: true },
          { answer: 'Un protocole réseau sécurisé', isCorrect: false },
          { answer: 'Une méthode de compression de données', isCorrect: false },
        ],
      },
      {
        title:
          'Quelles sont les bonnes pratiques pour stocker des mots de passe ? (Plusieurs réponses)',
        commentary: 'Question sur la sécurité des mots de passe',
        isQcm: true,
        isMultiple: true,
        maxPoints: 4,
        answers: [
          { answer: 'Utiliser un algorithme de hashing (bcrypt, argon2)', isCorrect: true },
          { answer: 'Ajouter un salt unique par utilisateur', isCorrect: true },
          { answer: 'Stocker en clair dans la base de données', isCorrect: false },
          { answer: 'Utiliser MD5', isCorrect: false },
        ],
      },
      {
        title: "Quel type d'attaque consiste à injecter du code SQL malveillant ?",
        commentary: 'Question sur les attaques web',
        isQcm: true,
        isMultiple: false,
        maxPoints: 4,
        answers: [
          { answer: 'XSS (Cross-Site Scripting)', isCorrect: false },
          { answer: 'SQL Injection', isCorrect: true },
          { answer: 'CSRF (Cross-Site Request Forgery)', isCorrect: false },
          { answer: 'DDoS', isCorrect: false },
        ],
      },
      {
        title:
          'Expliquez la différence entre authentification et autorisation, et donnez des exemples.',
        commentary: 'Question ouverte sur la sécurité',
        isQcm: false,
        isMultiple: false,
        maxPoints: 8,
        possibleCustomAnswers: [
          "L'authentification vérifie l'identité d'un utilisateur (login/password, JWT, OAuth). L'autorisation détermine ce que l'utilisateur peut faire (permissions, rôles). Exemple : se connecter = authentification, accéder à une page admin = autorisation.",
          "Authentification : prouver qui on est (connexion avec identifiants, biométrie, 2FA). Autorisation : déterminer les droits d'accès (RBAC, ACL). Un utilisateur authentifié n'est pas forcément autorisé à accéder à toutes les ressources.",
          "L'authentification établit l'identité (qui êtes-vous ?), l'autorisation contrôle les accès (que pouvez-vous faire ?). Exemple : JWT pour authentification, middleware de vérification des rôles pour autorisation.",
        ],
      },
    ],
  },
  {
    title: 'Architecture logicielle et Design Patterns',
    desc: "Examen sur les patterns de conception et l'architecture",
    time: 120,
    questions: [
      {
        title: "Qu'est-ce que le pattern Singleton ?",
        commentary: 'Question sur les design patterns',
        isQcm: true,
        isMultiple: false,
        maxPoints: 4,
        answers: [
          { answer: 'Un pattern qui permet de créer plusieurs instances', isCorrect: false },
          { answer: "Un pattern qui garantit une seule instance d'une classe", isCorrect: true },
          { answer: "Un pattern de création d'objets complexes", isCorrect: false },
          { answer: 'Un pattern de communication entre objets', isCorrect: false },
        ],
      },
      {
        title: 'Quels sont les principes SOLID ? (Plusieurs réponses)',
        commentary: 'Question sur les principes de conception',
        isQcm: true,
        isMultiple: true,
        maxPoints: 5,
        answers: [
          { answer: 'Single Responsibility', isCorrect: true },
          { answer: 'Open/Closed', isCorrect: true },
          { answer: 'Liskov Substitution', isCorrect: true },
          { answer: 'Interface Segregation', isCorrect: true },
          { answer: 'Dependency Inversion', isCorrect: true },
        ],
      },
      {
        title: "Quel pattern permet de séparer la logique métier de l'interface utilisateur ?",
        commentary: 'Question sur les patterns architecturaux',
        isQcm: true,
        isMultiple: false,
        maxPoints: 3,
        answers: [
          { answer: 'Singleton', isCorrect: false },
          { answer: 'MVC (Model-View-Controller)', isCorrect: true },
          { answer: 'Factory', isCorrect: false },
          { answer: 'Observer', isCorrect: false },
        ],
      },
      {
        title: "Expliquez le principe d'injection de dépendances et ses avantages.",
        commentary: "Question ouverte sur l'injection de dépendances",
        isQcm: false,
        isMultiple: false,
        maxPoints: 8,
        possibleCustomAnswers: [
          "L'injection de dépendances consiste à fournir les dépendances d'une classe de l'extérieur plutôt que de les créer à l'intérieur. Avantages : meilleure testabilité (mocks), couplage faible, code plus maintenable, respect du principe d'inversion de dépendances.",
          "Au lieu qu'une classe crée ses propres dépendances, elles sont injectées via le constructeur, les setters ou l'interface. Cela facilite les tests unitaires, permet de changer les implémentations facilement, et rend le code plus modulaire.",
          "C'est un pattern où les dépendances sont passées à une classe au lieu d'être instanciées en dur. Bénéfices : facilite le testing avec des mocks, permet le remplacement facile d'implémentations, améliore la maintenabilité et le découplage.",
        ],
      },
    ],
  },
  {
    title: 'Git et gestion de versions',
    desc: 'Évaluation sur Git et les bonnes pratiques de gestion de code',
    time: 60,
    questions: [
      {
        title: "Qu'est-ce que Git ?",
        commentary: 'Question de base sur Git',
        isQcm: true,
        isMultiple: false,
        maxPoints: 3,
        answers: [
          { answer: 'Un langage de programmation', isCorrect: false },
          { answer: 'Un système de gestion de versions distribué', isCorrect: true },
          { answer: 'Un framework JavaScript', isCorrect: false },
          { answer: 'Un serveur web', isCorrect: false },
        ],
      },
      {
        title: 'Quelles commandes Git permettent de gérer les branches ? (Plusieurs réponses)',
        commentary: 'Question sur les branches Git',
        isQcm: true,
        isMultiple: true,
        maxPoints: 5,
        answers: [
          { answer: 'git branch', isCorrect: true },
          { answer: 'git checkout', isCorrect: true },
          { answer: 'git merge', isCorrect: true },
          { answer: 'git install', isCorrect: false },
        ],
      },
      {
        title: "Quelle commande permet d'annuler le dernier commit en gardant les modifications ?",
        commentary: 'Question sur les commandes Git',
        isQcm: true,
        isMultiple: false,
        maxPoints: 4,
        answers: [
          { answer: 'git reset --soft HEAD~1', isCorrect: true },
          { answer: 'git revert HEAD', isCorrect: false },
          { answer: 'git reset --hard HEAD~1', isCorrect: false },
          { answer: 'git delete HEAD', isCorrect: false },
        ],
      },
      {
        title: 'Expliquez la différence entre git merge et git rebase.',
        commentary: 'Question ouverte sur Git',
        isQcm: false,
        isMultiple: false,
        maxPoints: 8,
        possibleCustomAnswers: [
          "git merge crée un commit de fusion et conserve l'historique complet des branches. git rebase réapplique les commits d'une branche sur une autre en créant un historique linéaire. Merge préserve l'historique, rebase le nettoie mais réécrit les commits.",
          "Merge fusionne deux branches en créant un nouveau commit avec deux parents. Rebase déplace les commits d'une branche à la fin d'une autre, créant un historique linéaire. Rebase est utile pour nettoyer l'historique mais ne doit pas être utilisé sur des branches publiques.",
          "git merge garde l'historique des deux branches et crée un commit de merge. git rebase réécrit l'historique en plaçant les commits d'une branche au-dessus de l'autre. Merge est plus sûr pour les branches partagées, rebase donne un historique plus propre.",
        ],
      },
    ],
  },
  {
    title: 'DevOps et intégration continue',
    desc: 'Examen sur les pratiques DevOps, CI/CD et conteneurisation',
    time: 90,
    questions: [
      {
        title: "Qu'est-ce que Docker ?",
        commentary: 'Question sur la conteneurisation',
        isQcm: true,
        isMultiple: false,
        maxPoints: 4,
        answers: [
          { answer: 'Un langage de programmation', isCorrect: false },
          { answer: 'Une plateforme de conteneurisation', isCorrect: true },
          { answer: "Un système d'exploitation", isCorrect: false },
          { answer: 'Un outil de monitoring', isCorrect: false },
        ],
      },
      {
        title: "Quels sont les avantages de l'intégration continue ? (Plusieurs réponses)",
        commentary: 'Question sur CI/CD',
        isQcm: true,
        isMultiple: true,
        maxPoints: 4,
        answers: [
          { answer: 'Détection rapide des bugs', isCorrect: true },
          { answer: 'Déploiements plus fréquents', isCorrect: true },
          { answer: 'Meilleure qualité du code', isCorrect: true },
          { answer: 'Augmentation des coûts', isCorrect: false },
        ],
      },
      {
        title: "Quel outil est utilisé pour l'orchestration de conteneurs ?",
        commentary: "Question sur l'orchestration",
        isQcm: true,
        isMultiple: false,
        maxPoints: 4,
        answers: [
          { answer: 'Docker Compose', isCorrect: false },
          { answer: 'Kubernetes', isCorrect: true },
          { answer: 'Jenkins', isCorrect: false },
          { answer: 'Git', isCorrect: false },
        ],
      },
      {
        title: "Expliquez ce qu'est un pipeline CI/CD et ses étapes principales.",
        commentary: 'Question ouverte sur CI/CD',
        isQcm: false,
        isMultiple: false,
        maxPoints: 8,
        possibleCustomAnswers: [
          "Un pipeline CI/CD automatise le processus de build, test et déploiement. Étapes : récupération du code (git pull), build (compilation), tests automatisés (unitaires, intégration), analyse de code, création d'artefacts, déploiement en staging puis production.",
          "Le pipeline CI/CD est une série d'étapes automatisées : 1) Commit du code 2) Build automatique 3) Tests (unit, integration, e2e) 4) Analyse de qualité 5) Déploiement automatique. Cela permet des livraisons rapides et fiables.",
          "C'est un workflow automatisé qui prend le code source et le déploie en production. Phases : intégration (merge, build, test), livraison (packaging, staging), déploiement (production). Utilise des outils comme Jenkins, GitLab CI, GitHub Actions.",
        ],
      },
    ],
  },
]
